// This is the more Windows(tm) adapted version of my PCX class
// works with Watcom for Win95 at least...last changes made in 1999
// supports reading of 8 and 24-bit images and writing of 8-bit
// images. I also have a version reading 16-bit, but 16-bit PCX-
// images are just 24 bit images (since PCX doesn't support 16-bit)
// Still for use with DirectDraw every card seems to have it's own
// 16-bit format ;-) so you're probably better of writing it yourself ;-)
// if not email me and I can give you the source for the 16-bit too...
// (email is at the end of this message) 
// I'm sorry for the lack of comments and lack of consistency in
// the variable names...sigh!!
// I still think that this class is fairly small and simple to
// use (hey, I'm not saying that there's no improvements to be made,
// quite the opposite, there's A LOT of them, but it works great for
// me at least (ok, ok, it's easy enough for me to say since I've
// created it, but))
//
// Some more info (for sending thanks and bug-reports and other nonsense ;-),
// hey, hey, you can ask me questions on the sourcecode too):
//
// My name: Andreas Magnusson
// My email: md7amag@mdstud.chalmers.se
//
// I would be very pleased if you greeted me in your program if you
// decide to use this sourcecode, if you really don't want to do
// that, I think you should at least send me an email saying that
// this helped you out in some way with the program xyz or whatever
// your naming convention may be...
//
//
// Yep and here comes the disclaimer: You use this source code at
// your own risk and I can't be held responsible for any damage
// physical (on yourself, computer or other equipment/stuff)
// or psychological (mostly inside yourself I guess) that
// was caused while using this sourcecode in any way.
//


#include <stdio.h>
#include "pcx.h"

PALETTEENTRY TAPalette[256] = {
{0x00, 0x00, 0x00, 0x00},
{0x80, 0x00, 0x00, 0x00},
{0x00, 0x80, 0x00, 0x00},
{0x80, 0x80, 0x00, 0x00},
{0x00, 0x00, 0x80, 0x00},
{0x80, 0x00, 0x80, 0x00},
{0x00, 0x80, 0x80, 0x00},
{0x80, 0x80, 0x80, 0x00},
{0xC0, 0xDC, 0xC0, 0x00},
{0x54, 0x54, 0xFC, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0xFF, 0xEB, 0xF3, 0x00},
{0xEB, 0xC7, 0xD3, 0x00},
{0xD7, 0xA3, 0xB3, 0x00},
{0xC3, 0x87, 0x97, 0x00},
{0xAF, 0x6F, 0x7F, 0x00},
{0x9B, 0x5B, 0x63, 0x00},
{0x8B, 0x47, 0x4F, 0x00},
{0x7B, 0x3B, 0x47, 0x00},
{0x6F, 0x33, 0x3B, 0x00},
{0x63, 0x2B, 0x33, 0x00},
{0x57, 0x23, 0x2B, 0x00},
{0x4B, 0x1B, 0x27, 0x00},
{0x3B, 0x17, 0x1F, 0x00},
{0x2F, 0x0F, 0x17, 0x00},
{0x23, 0x0B, 0x0F, 0x00},
{0x17, 0x07, 0x0B, 0x00},
{0x73, 0xFF, 0xDF, 0x00},
{0x57, 0xE7, 0xBF, 0x00},
{0x43, 0xCF, 0x9F, 0x00},
{0x2F, 0xB7, 0x83, 0x00},
{0x1F, 0x9F, 0x67, 0x00},
{0x13, 0x8B, 0x4F, 0x00},
{0x0F, 0x77, 0x3F, 0x00},
{0x0B, 0x6B, 0x37, 0x00},
{0x07, 0x5F, 0x2F, 0x00},
{0x07, 0x53, 0x2B, 0x00},
{0x00, 0x47, 0x27, 0x00},
{0x00, 0x3F, 0x23, 0x00},
{0x00, 0x33, 0x1B, 0x00},
{0x00, 0x27, 0x17, 0x00},
{0x00, 0x1B, 0x0F, 0x00},
{0x00, 0x13, 0x0B, 0x00},
{0xE3, 0xEF, 0xFF, 0x00},
{0xC7, 0xDF, 0xE7, 0x00},
{0xAF, 0xCF, 0xCB, 0x00},
{0x93, 0xB7, 0xA7, 0x00},
{0x7F, 0x9F, 0x83, 0x00},
{0x6B, 0x87, 0x67, 0x00},
{0x5F, 0x6F, 0x53, 0x00},
{0x5F, 0x63, 0x47, 0x00},
{0x5B, 0x57, 0x3B, 0x00},
{0x53, 0x43, 0x33, 0x00},
{0x47, 0x3B, 0x2B, 0x00},
{0x3B, 0x33, 0x23, 0x00},
{0x2F, 0x2B, 0x1B, 0x00},
{0x23, 0x1F, 0x13, 0x00},
{0x17, 0x13, 0x0F, 0x00},
{0x0B, 0x0B, 0x07, 0x00},
{0xFB, 0xFB, 0xD7, 0x00},
{0xDF, 0xDF, 0xB7, 0x00},
{0xC3, 0xC3, 0x9B, 0x00},
{0xAB, 0xAB, 0x83, 0x00},
{0x93, 0x93, 0x6F, 0x00},
{0x77, 0x77, 0x57, 0x00},
{0x63, 0x63, 0x43, 0x00},
{0x53, 0x53, 0x33, 0x00},
{0x43, 0x43, 0x23, 0x00},
{0x33, 0x33, 0x17, 0x00},
{0x23, 0x23, 0x0F, 0x00},
{0x1B, 0x1B, 0x07, 0x00},
{0x17, 0x17, 0x07, 0x00},
{0x13, 0x13, 0x00, 0x00},
{0x0F, 0x0F, 0x00, 0x00},
{0x0B, 0x0B, 0x00, 0x00},
{0xFB, 0xFB, 0xFB, 0x00},
{0xEB, 0xEB, 0xEB, 0x00},
{0xDB, 0xDB, 0xDB, 0x00},
{0xCB, 0xCB, 0xCB, 0x00},
{0xBB, 0xBB, 0xBB, 0x00},
{0xAB, 0xAB, 0xAB, 0x00},
{0x9B, 0x9B, 0x9B, 0x00},
{0x8B, 0x8B, 0x8B, 0x00},
{0x7B, 0x7B, 0x7B, 0x00},
{0x6B, 0x6B, 0x6B, 0x00},
{0x5B, 0x5B, 0x5B, 0x00},
{0x4B, 0x4B, 0x4B, 0x00},
{0x3B, 0x3B, 0x3B, 0x00},
{0x2B, 0x2B, 0x2B, 0x00},
{0x1F, 0x1F, 0x1F, 0x00},
{0x0F, 0x0F, 0x0F, 0x00},
{0xEB, 0xF3, 0xFF, 0x00},
{0xCB, 0xE3, 0xFF, 0x00},
{0xAF, 0xCF, 0xFF, 0x00},
{0x97, 0xB3, 0xFF, 0x00},
{0x7B, 0x97, 0xFF, 0x00},
{0x67, 0x7F, 0xFF, 0x00},
{0x53, 0x6B, 0xEF, 0x00},
{0x3F, 0x5B, 0xE3, 0x00},
{0x33, 0x4B, 0xD7, 0x00},
{0x23, 0x3B, 0xCB, 0x00},
{0x17, 0x2F, 0xAF, 0x00},
{0x0F, 0x27, 0x97, 0x00},
{0x07, 0x1F, 0x7B, 0x00},
{0x07, 0x17, 0x63, 0x00},
{0x00, 0x0F, 0x47, 0x00},
{0x00, 0x0B, 0x2F, 0x00},
{0xE3, 0xF7, 0xFF, 0x00},
{0xBF, 0xDB, 0xE7, 0x00},
{0x9F, 0xBF, 0xCF, 0x00},
{0x83, 0xA7, 0xB7, 0x00},
{0x6B, 0x8F, 0xA3, 0x00},
{0x53, 0x77, 0x8B, 0x00},
{0x3F, 0x5F, 0x73, 0x00},
{0x2F, 0x4B, 0x5F, 0x00},
{0x27, 0x3F, 0x57, 0x00},
{0x23, 0x37, 0x4F, 0x00},
{0x1F, 0x2F, 0x47, 0x00},
{0x1B, 0x27, 0x3F, 0x00},
{0x17, 0x1F, 0x37, 0x00},
{0x13, 0x1B, 0x2F, 0x00},
{0x0F, 0x13, 0x27, 0x00},
{0x0B, 0x0F, 0x1F, 0x00},
{0xD7, 0xEF, 0xFF, 0x00},
{0xBB, 0xE3, 0xEF, 0x00},
{0x9B, 0xCB, 0xDF, 0x00},
{0x83, 0xB7, 0xCF, 0x00},
{0x6B, 0xA3, 0xC3, 0x00},
{0x53, 0x8F, 0xB3, 0x00},
{0x3F, 0x7B, 0xA3, 0x00},
{0x2F, 0x6B, 0x97, 0x00},
{0x23, 0x5B, 0x87, 0x00},
{0x1B, 0x4B, 0x77, 0x00},
{0x13, 0x3F, 0x67, 0x00},
{0x0B, 0x33, 0x57, 0x00},
{0x07, 0x27, 0x47, 0x00},
{0x00, 0x1B, 0x37, 0x00},
{0x00, 0x13, 0x27, 0x00},
{0x00, 0x0B, 0x1B, 0x00},
{0xFF, 0xE7, 0xFF, 0x00},
{0xE7, 0xC7, 0xEB, 0x00},
{0xD3, 0xAB, 0xD7, 0x00},
{0xBB, 0x93, 0xC3, 0x00},
{0xA7, 0x7B, 0xB3, 0x00},
{0x8F, 0x63, 0x9F, 0x00},
{0x77, 0x4B, 0x8F, 0x00},
{0x63, 0x3B, 0x7F, 0x00},
{0x4F, 0x2B, 0x6F, 0x00},
{0x43, 0x1F, 0x63, 0x00},
{0x37, 0x17, 0x57, 0x00},
{0x2B, 0x0F, 0x47, 0x00},
{0x1F, 0x07, 0x3B, 0x00},
{0x13, 0x00, 0x2B, 0x00},
{0x0B, 0x00, 0x1F, 0x00},
{0x07, 0x00, 0x13, 0x00},
{0xD7, 0xFF, 0xA7, 0x00},
{0xAB, 0xE7, 0x7F, 0x00},
{0x83, 0xD3, 0x5B, 0x00},
{0x67, 0xBF, 0x3F, 0x00},
{0x4B, 0xAB, 0x2B, 0x00},
{0x43, 0x97, 0x2B, 0x00},
{0x37, 0x87, 0x27, 0x00},
{0x2F, 0x77, 0x1B, 0x00},
{0x2B, 0x67, 0x13, 0x00},
{0x23, 0x5B, 0x0F, 0x00},
{0x1F, 0x4F, 0x0B, 0x00},
{0x1B, 0x43, 0x07, 0x00},
{0x17, 0x33, 0x00, 0x00},
{0x0F, 0x27, 0x00, 0x00},
{0x0B, 0x1B, 0x00, 0x00},
{0x07, 0x0F, 0x00, 0x00},
{0xFF, 0xE3, 0x9F, 0x00},
{0xE3, 0xC7, 0x73, 0x00},
{0xCB, 0xAF, 0x53, 0x00},
{0xB3, 0x97, 0x3F, 0x00},
{0x9B, 0x83, 0x2F, 0x00},
{0x83, 0x6F, 0x23, 0x00},
{0x6B, 0x5B, 0x17, 0x00},
{0x53, 0x47, 0x0F, 0x00},
{0x4B, 0x3B, 0x0B, 0x00},
{0x43, 0x33, 0x07, 0x00},
{0x3B, 0x2B, 0x07, 0x00},
{0x37, 0x23, 0x00, 0x00},
{0x2F, 0x1B, 0x00, 0x00},
{0x27, 0x13, 0x00, 0x00},
{0x1F, 0x0F, 0x00, 0x00},
{0x1B, 0x0B, 0x00, 0x00},
{0xFF, 0xFF, 0xA3, 0x00},
{0xFB, 0xF3, 0x83, 0x00},
{0xF7, 0xE3, 0x67, 0x00},
{0xF3, 0xD3, 0x4F, 0x00},
{0xEF, 0xBB, 0x33, 0x00},
{0xEF, 0xA7, 0x1B, 0x00},
{0xEB, 0x8F, 0x13, 0x00},
{0xE7, 0x7B, 0x0F, 0x00},
{0xDF, 0x4F, 0x07, 0x00},
{0xD7, 0x23, 0x00, 0x00},
{0xBF, 0x1F, 0x00, 0x00},
{0xA7, 0x1B, 0x00, 0x00},
{0x93, 0x17, 0x00, 0x00},
{0x7B, 0x13, 0x00, 0x00},
{0x63, 0x13, 0x00, 0x00},
{0x4F, 0x0F, 0x00, 0x00},
{0xFF, 0xFF, 0x00, 0x00},
{0xFF, 0xBF, 0x00, 0x00},
{0xFF, 0x83, 0x00, 0x00},
{0xFF, 0x47, 0x00, 0x00},
{0xD3, 0x2B, 0x00, 0x00},
{0xAB, 0x17, 0x00, 0x00},
{0x7F, 0x07, 0x00, 0x00},
{0x57, 0x00, 0x00, 0x00},
{0xDF, 0xCB, 0xFF, 0x00},
{0xBB, 0x9F, 0xDF, 0x00},
{0x9B, 0x77, 0xBF, 0x00},
{0x7F, 0x57, 0x9F, 0x00},
{0x67, 0x3B, 0x7F, 0x00},
{0x4B, 0x23, 0x5F, 0x00},
{0x33, 0x13, 0x3F, 0x00},
{0x1B, 0x07, 0x1F, 0x00},
{0xD3, 0xDB, 0xFF, 0x00},
{0x87, 0x9F, 0xF7, 0x00},
{0x43, 0x6F, 0xEF, 0x00},
{0x17, 0x47, 0xE7, 0x00},
{0x0B, 0x2B, 0xBB, 0x00},
{0x07, 0x17, 0x8F, 0x00},
{0x00, 0x07, 0x63, 0x00},
{0x00, 0x00, 0x37, 0x00},
{0x7B, 0xFF, 0x77, 0x00},
{0x53, 0xDF, 0x4F, 0x00},
{0x33, 0xBF, 0x2B, 0x00},
{0x1B, 0x9F, 0x13, 0x00},
{0x1B, 0x7F, 0x0B, 0x00},
{0x17, 0x5F, 0x07, 0x00},
{0x13, 0x3F, 0x00, 0x00},
{0x0B, 0x1F, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00},
{0xFF, 0xFB, 0xF0, 0x00},
{0xA0, 0xA0, 0xA4, 0x00},
{0x80, 0x80, 0x80, 0x00},
{0xFF, 0x00, 0x00, 0x00},
{0x00, 0xFF, 0x00, 0x00},
{0xFF, 0xFF, 0x00, 0x00},
{0x00, 0x00, 0xFF, 0x00},
{0xFF, 0x00, 0xFF, 0x00},
{0x00, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0x00}};

PCX::PCX()
{
	lpBuffer = NULL;
	palette = new PALETTEENTRY[256];
}


PCX::~PCX()
{
	Erase();
	if(palette)
		delete[] palette;
}

BYTE *PCX::SetBuffer(BYTE *b)
{
	if(lpBuffer)
		Erase();
	return lpBuffer = b;
}

void PCX::SetPalette(PALETTEENTRY *p)
{
	if(palette)
		delete [] palette;
	palette = p;
}

void PCX::CopyPalette(PALETTEENTRY *p)
{
	if(!palette)
		palette = new PALETTEENTRY[256];
	memcpy(palette, p, 256 * sizeof(PALETTEENTRY));
}

BOOL PCX::Load(const char *filename, BOOL fOnlyHeader)
{
	short num_bytes, i;
	long count;
	BYTE data;
	DWORD bw = 0;

	HANDLE file = CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if((!file)
		||(INVALID_HANDLE_VALUE==file))
		return FALSE;

	ReadFile(file, &header, sizeof(header), &bw, NULL);


	long lFileSize = GetFileSize(file, NULL) - sizeof(header);

	 nWidth = header.height- header.y+1;
	 nHeight = header.width- header.x+1;
	lSize = (nHeight*nWidth);
	lImageSize = lSize;
	lSize= (lSize* (header.bits_per_pixel/ 8)/ 1000+ 1)* 1000;

	if(lpBuffer)
	{
		Erase();
	}
	if(fOnlyHeader)
	{
		CloseHandle(file);
		Erase();
		return TRUE;
	}
	//
	BYTE *tmpbuf = (BYTE *)malloc (lFileSize);
	BYTE *svtmpbuf = tmpbuf; // to delete tmpbuf later...

	if(tmpbuf == NULL)
	{
		CloseHandle(file);
		return FALSE;
	}

	lpBuffer = new BYTE[lSize];
	if (lpBuffer == NULL )
	{
		delete [] svtmpbuf;
		CloseHandle(file);
		return FALSE;
	}
	ReadFile ( file, tmpbuf, lFileSize, &bw, NULL);
	CloseHandle(file);
	count = 0;
	while(count < lImageSize)
	{
		data = *tmpbuf++;
		if((data >= 192) && (data <= 255))
		{
			num_bytes = data - 192;
			data  = *tmpbuf++;
			while(num_bytes-- > 0)
			{
				lpBuffer[count++] = data;
			}
		}
		else
		{
			lpBuffer[count++] = data;
		}
	}

	if(header.num_color_planes == 1)
	{
		while(*tmpbuf++ != 0xc); 
		for(i = 0; i < 256; i++)
		{
			palette[i].peRed   = *tmpbuf++;
			palette[i].peGreen = *tmpbuf++;
			palette[i].peBlue  = *tmpbuf++;
			palette[i].peFlags = PC_EXPLICIT;
		}
	}
	free (svtmpbuf);
	return TRUE;
}

// this function reads a single line from a 24-bit PCX-image
// put values from 0 to 2 in iStartPos to store the line's
// data at the right position (look in Load24() for further info)
BYTE *PCX::ReadLine24(BYTE *pbuf, DWORD line, short iStartPos)
{
	DWORD lByteCount = 0, lBytesRead = 0, lWritePos = iStartPos;
	BYTE data;
	BYTE *buffer24 = (BYTE *)&lpBuffer[line * 3];
	while(lBytesRead < static_cast<DWORD>(header.width + 1))
	{
		data = *pbuf++;
		if((data >= 192) && (data <= 255))
		{
			lByteCount = data - 192;
			data  = *pbuf++;
			while(lByteCount-- > 0)
			{
				buffer24[lWritePos] = data;
				lWritePos += 3;
				lBytesRead++;
			}
		}
		else
		{
			buffer24[lWritePos] = data;
			lWritePos += 3;
			lBytesRead++;
		}
	}
	return pbuf;
}

// This function loads a 24-bit PCX-file into a buffer with the format
// R G B R G B...  or  B G R B G R...  or any combination you like
// note that it does not load the file into three different bit-planes
// although it wouldn't be too hard to fix that if you prefer it.
BOOL PCX::Load24(const char *filename)
{
	short i;
	DWORD bw = 0;

	HANDLE file = CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if(!file)
		return FALSE;

	ReadFile(file, &header, sizeof(header), &bw, NULL);

	long lFileSize = GetFileSize(file, NULL) - sizeof(header);

	long nWidth = header.width + 1;
	long nHeight = header.height + 1;
	long lSize = nWidth * nHeight * 3;
	lImageSize = lSize;
	if(lpBuffer)
	{
		delete[] lpBuffer;
		lpBuffer= NULL;
	}

	BYTE *tmpbuf = new BYTE[lFileSize];
	BYTE *svtmpbuf = tmpbuf; // to delete tmpbuf later...

	lpBuffer = new BYTE[lSize];
	if(lpBuffer == NULL || tmpbuf == NULL)
	{
		CloseHandle(file);
		return FALSE;
	}
	memset(lpBuffer, 0, lSize);
	ReadFile(file, tmpbuf, lFileSize, &bw, NULL);
	CloseHandle(file);

	// the data is stored as bitplanes in the pcx-image, thus first a row of red, then a row
	// of green and finally a row of blue. Then comes next row of red...
	// so, depending on the videocard you might want to swap the last numbers in the
	// ReadLine24() call. If your card has the format RGB, then the numbers would be
	// (0,1,2) or if you like me has a card with the BGR format then you should have
	// them like below (2,1,0)
	for(i = 0; i < nHeight; i++)
	{
		tmpbuf = ReadLine24(tmpbuf, i * nWidth, 2);
		tmpbuf = ReadLine24(tmpbuf, i * nWidth, 1);
		tmpbuf = ReadLine24(tmpbuf, i * nWidth, 0);
	}
	delete[] svtmpbuf;

	// transformer
	return TRUE;
}


// this writes an 8-bit PCX-encoded line used by Save() (below)
BYTE *PCX::WriteLine(BYTE *pbuf, DWORD line)
{
	short bytes = header.bytes_per_line;
	BYTE *buf = &lpBuffer[line];
	long numb = 0, wb = 0;
	BYTE last = buf[0];
	short runlen = 1;
	for(short i = 1; i < bytes; i++)
	{
		if(buf[i] == last && runlen < 63)
		{
			runlen++;
		}
		else
		{
			if(runlen > 1 || last > 0xbf)
			{
				*pbuf++ = (BYTE)(runlen | 0xc0);
				wb++;
			}
			*pbuf++ = last;
			wb++;
			numb += runlen;
			last = buf[i];
			runlen = 1;
		}
	}

	if(runlen)
	{
		if(runlen > 1 || last > 0xbf)
		{
			*pbuf++ = (BYTE)(runlen | 0xc0);
			wb++;
		}
		*pbuf++ = last;
		wb++;
		numb += runlen;
	}
	return pbuf;
}



// This function will save a pcx image to disk under the filename
// in 'filename'
// OBSERVE! If you try to save an image that wasn't loaded (with Load()),
// but scanned from the screen for instance, you need to manually set the
// width and height in the header (header.width = screen width - 1,
// header.height = screen height - 1) and buffer must point to the image
// being saved
BOOL PCX::Save(const char *filename)
{
	if(lpBuffer == NULL)
		return FALSE;

	BOOL bScrShotMode = FALSE;
	char *fname = NULL;
	if(!filename)
	{
		// To be able to save screenshots with the name scrshotx where x is a number
		// see below
		bScrShotMode = TRUE;
		fname = new char[20];
	}
	long nWidth = header.width + 1;
	long nHeight = header.height + 1;
	long size = nWidth * nHeight;
	BYTE *pack = NULL, *bpack;
	// hopefully the amount of bytes packed will never
	// be bigger than the original size, but if it does
	// try making it bigger. OBSERVE that it will if your
	// image consists of a lot of vertical lines and the
	// lines are drawn with a color above 191
	pack = new BYTE[size*2];
	if(!pack)
     return FALSE;
	bpack = pack;

	short index = 0;

	HANDLE file;

	if(bScrShotMode)
	{
		do
		{
			wsprintf(fname, "scrshot%i.pcx", index++);
			file = CreateFile(fname, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
		}while(file == INVALID_HANDLE_VALUE);
		// this might be a bit hazardous - never-ending-loop warning
	}
	else
	{
		file = CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if(file == INVALID_HANDLE_VALUE)
			return FALSE;
	}
	// setup pcxheader to standard values
	header.manufacturer = 10;
	header.version = 5;
	header.encoding = 1;
	header.bits_per_pixel = 8;
	header.x = 0;
	header.y = 0;

	header.horz_res = 300;
	header.vert_res = 300;
	header.bytes_per_line = header.width + 1;
	header.num_color_planes = 1;
	header.palette_type = 1;

	DWORD dwWrb;
	WriteFile(file, &header, sizeof(header), &dwWrb, NULL);

	for(short i = 0; i < nHeight; i++)
	{
		bpack = WriteLine(bpack, i * nWidth);
	}

	WriteFile(file, pack, (long)bpack - (long)pack, &dwWrb, NULL);

	BYTE *tmppal = new BYTE[769];
	tmppal[0] = 0xc;
	int ii = 1;
	for(index = 0; index < 256; index++)
	{
		tmppal[ii++] = palette[index].peRed;
		tmppal[ii++] = palette[index].peGreen;
		tmppal[ii++] = palette[index].peBlue;
	}

	WriteFile(file, tmppal, 769, &dwWrb, NULL);

	delete[] tmppal;

	CloseHandle(file);
	delete pack;
	return TRUE;
}



BYTE *PCX::NewBuffer(short w, short h)
{
	Erase();
	header.width = w - 1;
	header.height = h - 1;
	header.bytes_per_line = w;
	lImageSize = w * h;
	//lpBuffer = new BYTE[lImageSize];
	return lpBuffer;
}

void PCX::Erase()
{
	if(lpBuffer)
		delete[] lpBuffer;
	lpBuffer= NULL;
}

long PCX::Width()
{
	// note that this function returns the width in pixels, not in bytes!
	return nWidth;
}

long PCX::Height()
{
	return nHeight;
}


